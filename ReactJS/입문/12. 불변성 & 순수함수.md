 # 불변성 & 순수함수?
#불변성 #순수함수

```ad-summary
title: 목표
1. 불변성의 개념과, 변수가 메모리에 저장되는 과정에서 원시데이터가 아닌 데이터의 불변성 유지여부가 중요한 이유를 설명할 수 있다.
```

## 컴포넌트 생명주기 
#컴포넌트생명주기

React의 생명주기는 **Mount** ➜ **Updating** ➜ **Unmounting**
즉, 화면상에 **떠오르고** ➜ **갱신되고** ➜ **죽는다** 라고 생각 하면 된다.

여기서 갱신 된다는 의미는 render 라는걸 통해서 이뤄진다는 의미이다.

![](https://i.imgur.com/EdCGqU1.png)


## 1. 불변성 이란?

불변성은 메모리에 있는 값을 변경할 수 없는것을 뜻한다. 자바스크립트의 데이터 형태중에서 **원시 데이터**는 **불변성**이 있고, 원시 데이터가 아닌 **객체**, **배열**, **함수**는 **불변성이없다.**

## 2. 변수를 저장하면 메모리에 어떻게 저장 되는가?

```js
let number = 1;
let secondNumber = 1;

console.log(number === secondNumber) // true
```

만약  `let number = 1` 이라고 선언을 하면, 메모리에는 1 이라는 값이 저장된다. 그리고 `number` 라는 **변수는 메모리에 있는 1을 참조**한다.

이어서  `let secondNumber = 1` 이라고 다른 변수를 선언을 했다고 가정하자. 

이때도 자바스크립트는 이미 메모리에 생성되어 있는 1이라는 값을 참조한다.

즉, number와 secondNumber는 변수의 이름은 다르지만, 같은 메모리의 값을 바라보고 있는 것!
그래서 콘솔에 `number === secondNumber` 를 하면 `true`가 보이게 되는것이다.

### 원시 데이터? 
숫자, 문자, 불리언

### 원시 데이터가 아닌것?
배열, 객체, 함수 ...

하지만 원시데이터가 아닌 값(객체, 배열, 함수)는 이렇지 않다.

`let obj_1 = {name: ‘kim’}` 이라는 값을 선언하면 메모리에 obj_1이 저장이 된다.

그리고 이어서 `let obj_2 = {name: ‘kim’}` 이라고 같은 값을 선언하면 **obj_2라는 메모리 공간에 새롭게 저장**이 된다. **그래서 `obj_1 === obj2` 는 `false` 가 되는것!

```js
let obj1 = {
	name: 'kim', 
}

let obj2 = {
	name: 'kim',
}

console.log(obj1 === obj2) //false
```

## 3. 데이터를 수정하면

원시 데이터에서 기존에 1이던 number를 `number = 2` 라고 새로운 값을 할당하면 메모리에서 1이라는 값이 변하지 않고, 새로운 메모리 저장공간에 2가 생긴 뒤 number 라는 값을 새로운 메모리 공간에 저장된 2를 참조하게 된다. 즉, **원시 데이터는 불변성이 있다.** 

원시 데이터가 아닌 함수, 객체, 배열은 **불변성이 없다.**

obj_1에서 `obj_1.name = ‘park’` 이라고 새로운 값을 할당하면 기존 메모리 저장공간에 있는 `{name: ‘kim’}` 이라는 값이 `{name : ‘park’}` 으로 바뀌어 버린다.

### 정리
**원시데이터**는 수정을 했을 때 **메모리에 저장된 값 자체는 바꿀 수 없고**, **새로운 메모리 저장공간**에 새로운 값을 저장한다. [불변성을 지켜준다.]

**원시데이터가 아닌 데이터**는 수정했을 때 기존에 저장되어 있던 **메모리 저장공간의 값 자체를 바꿔**버린다. [불변성이 있다.]

## 4. ReactJS 에서의 불변성
#React불변성

리액트에서 객체와 배열 타입의 상태를 다룰때는 불변성을 지켜야 한다. 불변성을 지킨다는 것은 객체 또는 배열을 직접 수정하지 않는다는 것을 의미한다. 

```ad-tip
리액트는 화면을 렌더링 할지를 state의 변화에 따라 결정한다.
단순 변수는 무시한다.
```

리액트는 state의 수정 여부를 확인할때 메모리 주소를 비교하는데, 만약 리액트에서 원시데이터가 아닌 데이터를 수정할때 불변성을 지켜주지 않고, 직접 수정하면 값은 바뀌고 메모리 주소는 그대로 일것이다. 

왜냐하면 불변성을 지키지 않고 코드를 작성하게 된다면 props의 변화 상태를 감지할수 없으므로 렌더링 여부를 알수 없기 때문!

그렇기에 선언한 객체나 배열을 다른 값으로 변경하고 싶을때는  깊은 복사를 통해 새로운 객체나 배열을 생성해야 한다.  

```ad-info
RactJS에서 불변성을 지켜야 하는 이유는 렌더링 성능 최적화 방식 때문이다.
```

리액트에서는 부모 컴포넌트가 리렌더링 되면 기본적으로 자식 컴포넌트들 또한 리렌더링 되는데, 문제는 변경사항이 없는 컴포넌트들도 리렌더링 된다는 것이다. #propsDrilling 

리액트는 최적화가 많이 되어 있어 리렌더링 된다고 성능에 부하가 발생하진 않지만, 컴포넌트에서 다루는 데이터가 많아지거나 연산량이 늘어난 경우는 컴포넌트에 변화가 발생했을때만 리렌더링 되도록 최적화 해야한다. 

변화를 감지하는 방법은 props의 변화를 통해 알수 있다. 

컴포넌트의 렌더링 성능을 최적화 하기 위해서는 이전에 컴포넌트가 들고 있던 props와 새로 받아올 props를 비교하는 과정이 필요한데 이 과정에서 **불변성을 유지하는것이 정말 중요**하다. 

## 5. ReactJS에서 불변성 유지법

### 문제점
일단 React에서 객체를 버튼을 통해 수정해보면 아래와 같은 결과를 볼 수 있다.
onClick으로 obj의 name을 변경했지만, 메모리 주소가 같기 때문에 리렌더링은 되지 않아 UI에서 보이질 않는다.
```jsx
import React, { useState } from 'react';

const App = () => {
  const [obj, setObj] = useState({
    name: '서근',
    age: 20,
  });
  return (
    <div>
      <div>{obj.name}</div>
      <button
        onClick={() => {
          obj.name = '미진';
          console.log(obj); //{name: '미진', age: 20}
          setObj(obj); // obj는 바꼈지만 렌더링은 되지 않았다. (메모리 주소가 같기때문)
        }}
      >
        변경
      </button>
    </div>
  );
};

export default App;
```

이것을 해결하기 위해서는 메모리 주소를 다른 주소로 바라보게끔 해줘야 한다. 
즉, 아예 다른 객체를 생성해야한다는 의미!

### 해결 방법
스프레드 문법을 사용하면 다른 객체를 생성할 수 있다.  #스프레드

```ad-tip
배열 또는 객체가 나오면 스프레드를 사용해 깊은 복사를 하자!
```

```jsx
import React, { useState } from 'react';

const App = () => {
  const [obj, setObj] = useState({
    name: '서근',
    age: 20,
  });
  return (
    <div>
      <div>{obj.name}</div>
      <button
        onClick={() => {
          const obj2 = { ...obj }; //완전히 새로운 주소값으로 복사
          obj2.name = '미진';
          console.log(obj2); //{name: '미진', age: 20}
          setObj(obj2); // 렌더링 완료!
        }}
      >
        변경
      </button>
    </div>
  );
};

export default App;

```



